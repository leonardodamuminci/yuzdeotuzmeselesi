name: RSI Wick Touch Scan (binance-only)

on:
  schedule:
    - cron: '*/30 * * * *'   # Her 30 dakikada bir (UTC)
  workflow_dispatch: {}       # (Ä°stersen elle de tetikleyebil)

jobs:
  scan:
    runs-on: ubuntu-latest
    steps:
      - name: Run inline Python (Binance only)
        env:
          TELEGRAM_BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
          TELEGRAM_CHAT_ID: ${{ secrets.TELEGRAM_CHAT_ID }}
          # Ä°stersen repo Variables kÄ±smÄ±na MAX_SYMBOLS ekleyebilirsin (Ã¶rn. 300); yoksa varsayÄ±lan 400.
          MAX_SYMBOLS: ${{ vars.MAX_SYMBOLS }}
        run: |
          python - <<'PY'
          import os, json, math, time, urllib.request, urllib.error
          from datetime import datetime, timezone, timedelta

          BOT  = (os.environ.get("TELEGRAM_BOT_TOKEN") or "").strip()
          CHAT = (os.environ.get("TELEGRAM_CHAT_ID") or "").strip()
          assert BOT and CHAT, "TELEGRAM_BOT_TOKEN / TELEGRAM_CHAT_ID eksik!"
          assert CHAT.isdigit(), "TELEGRAM_CHAT_ID sadece rakam olmalÄ±"
          if any(c in BOT for c in "\r\n\t"):
              raise ValueError("TELEGRAM_BOT_TOKEN tek satÄ±r olmalÄ±.")

          MAX_SYMBOLS = int(os.environ.get("MAX_SYMBOLS") or 400)
          RSI_LEN = 14
          SMA_LEN = 14
          BINANCE_BASES = [
              "https://api.binance.com",
              "https://api1.binance.com",
              "https://api2.binance.com",
              "https://api3.binance.com",
              # Binance resmi data aynasÄ± (resmi arÅŸiv servisi)
              "https://data-api.binance.vision"
          ]

          def http_get_json(url, timeout=20, headers=None):
              hdrs = {"User-Agent":"Mozilla/5.0"}
              if headers: hdrs.update(headers)
              req = urllib.request.Request(url, headers=hdrs)
              with urllib.request.urlopen(req, timeout=timeout) as r:
                  return json.loads(r.read().decode())

          def http_post_json(url, payload, timeout=20):
              data = json.dumps(payload).encode("utf-8")
              req = urllib.request.Request(url, data=data, headers={"Content-Type":"application/json"})
              with urllib.request.urlopen(req, timeout=timeout) as r:
                  return json.loads(r.read().decode())

          def send_tg(text):
              url = f"https://api.telegram.org/bot{BOT}/sendMessage"
              parts = [text[i:i+3900] for i in range(0, len(text), 3900)] or [text]
              for p in parts:
                  http_post_json(url, {"chat_id": CHAT, "text": p})

          # -------- Binance veri yardÄ±mcÄ±larÄ± --------
          def fetch_exchange_info():
              last_err = None
              for base in BINANCE_BASES:
                  try:
                      return http_get_json(f"{base}/api/v3/exchangeInfo"), base
                  except Exception as e:
                      last_err = e
                      continue
              raise last_err

          def fetch_klines(sym, limit=200):
              last_err = None
              for base in BINANCE_BASES:
                  url = f"{base}/api/v3/klines?symbol={sym}&interval=1d&limit={limit}"
                  try:
                      kl = http_get_json(url)
                      if kl and len(kl) >= 40:
                          return kl, base
                  except Exception as e:
                      last_err = e
                      continue
              raise last_err or RuntimeError("Klines alÄ±namadÄ±")

          # -------- GÃ¶stergeler --------
          def rsi_wilder(series, period):
              x = list(map(float, series))
              n = len(x); r = [math.nan]*n
              if n <= period: return r
              delta = [x[i]-x[i-1] for i in range(1,n)]
              gains = [d if d>0 else 0.0 for d in delta]
              losses= [-d if d<0 else 0.0 for d in delta]
              avg_g = [math.nan]*n; avg_l = [math.nan]*n
              avg_g[period] = sum(gains[:period])/period
              avg_l[period] = sum(losses[:period])/period
              for i in range(period+1, n):
                  avg_g[i] = (avg_g[i-1]*(period-1) + gains[i-1]) / period
                  avg_l[i] = (avg_l[i-1]*(period-1) + losses[i-1]) / period
              for i in range(period, n):
                  rs = avg_g[i] / (avg_l[i] + 1e-12)
                  r[i] = 100.0 - 100.0/(1.0+rs)
              return r

          def sma(arr, period):
              n = len(arr); out = [math.nan]*n
              for i in range(period-1, n):
                  window = arr[i-period+1:i+1]
                  if any(math.isnan(v) for v in window): continue
                  out[i] = sum(window)/period
              return out

          def now_tr():
              tr = timezone(timedelta(hours=3))
              return datetime.now(tr).strftime("%Y-%m-%d %H:%M:%S %Z")

          # -------- TARAMA --------
          def get_usdt_spot_symbols(max_n):
              info, used_base = fetch_exchange_info()
              syms = []
              for s in info.get("symbols", []):
                  if (s.get("status")=="TRADING"
                      and s.get("isSpotTradingAllowed", True)
                      and s.get("quoteAsset")=="USDT"):
                      sym = s["symbol"]
                      # kaldÄ±raÃ§/leveraged tokenlarÄ± Ã§Ä±kar
                      if any(x in sym for x in ["UP","DOWN","BULL","BEAR"]):
                          continue
                      syms.append(sym)
              syms = sorted(set(syms))
              return syms[:max_n], used_base

          def scan():
              symbols, base_info = get_usdt_spot_symbols(MAX_SYMBOLS)
              header = f"â±ï¸ {now_tr()}\nðŸ“¡ Binance 1D wick-touch (2 saatte 1)\nâ³ RSI={RSI_LEN}, SMA={SMA_LEN} | EÅŸikler: 0.7 / 1.3\nToplam sembol: {len(symbols)}\n"
              results = []
              used_sources = set([base_info])

              for idx, sym in enumerate(symbols, 1):
                  try:
                      kl, base_used = fetch_klines(sym, limit=200)
                      used_sources.add(base_used)
                      highs = [float(k[2]) for k in kl]
                      lows  = [float(k[3]) for k in kl]

                      rsi_low  = rsi_wilder(lows,  RSI_LEN)
                      rsi_high = rsi_wilder(highs, RSI_LEN)
                      sma_low  = sma(rsi_low,  SMA_LEN)
                      sma_high = sma(rsi_high, SMA_LEN)

                      rl_c, rl_p = rsi_low[-1],  rsi_low[-2]
                      sl_c, sl_p = sma_low[-1],  sma_low[-2]
                      rh_c, rh_p = rsi_high[-1], rsi_high[-2]
                      sh_c, sh_p = sma_high[-1], sma_high[-2]
                      low_c, high_c = lows[-1], highs[-1]

                      buy  = (not math.isnan(rl_c) and not math.isnan(sl_c) and
                              not math.isnan(rl_p) and not math.isnan(sl_p) and
                              rl_c <= sl_c*0.7 and rl_p > sl_p*0.7)

                      sell = (not math.isnan(rh_c) and not math.isnan(sh_c) and
                              not math.isnan(rh_p) and not math.isnan(sh_p) and
                              rh_c >= sh_c*1.3 and rh_p <  sh_p*1.3)

                      if buy:
                          tp = low_c*1.3
                          results.append(f"ðŸŸ¢ BUY {sym} @ {low_c:.8g} | TPâ‰ˆ{tp:.8g} | RSI(low)={rl_c:.2f} SMA(low)={sl_c:.2f}")
                      if sell:
                          tp = high_c/1.3
                          results.append(f"ðŸ”´ SELL {sym} @ {high_c:.8g} | TPâ‰ˆ{tp:.8g} | RSI(high)={rh_c:.2f} SMA(high)={sh_c:.2f}")

                      # nazik rate-limit
                      time.sleep(0.12)

                  except Exception as e:
                      results.append(f"ERR {sym}: {e}")

              src_note = " / ".join(sorted({s.split('//')[1].split('/')[0] for s in used_sources if s}))
              body = header + ("\n".join(results) if results else "â€¢ Ä°ÅŸlem yok") + f"\nâ„¹ï¸ Kaynak(lar): {src_note or 'binance'}"
              send_tg(body)

          if __name__ == "__main__":
              scan()
          PY
