name: RSI Wick Touch Scan (with fallback)

on:
  schedule:
    - cron: '0 */2 * * *'   # Her 2 saatte bir (UTC)
  workflow_dispatch: {}      # Elle Ã§alÄ±ÅŸtÄ±r

jobs:
  scan:
    runs-on: ubuntu-latest
    steps:
      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Run inline Python (Binance first, Yahoo fallback)
        env:
          TELEGRAM_BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
          TELEGRAM_CHAT_ID: ${{ secrets.TELEGRAM_CHAT_ID }}
        run: |
          python - <<'PY'
          import os, json, math, urllib.request, urllib.error
          from datetime import datetime, timezone, timedelta

          BOT  = (os.environ.get("TELEGRAM_BOT_TOKEN") or "").strip()
          CHAT = (os.environ.get("TELEGRAM_CHAT_ID") or "").strip()
          assert BOT and CHAT, "TELEGRAM_BOT_TOKEN / TELEGRAM_CHAT_ID eksik!"
          assert CHAT.isdigit(), "TELEGRAM_CHAT_ID sadece rakam olmalÄ±"
          if any(c in BOT for c in "\r\n\t"):
              raise ValueError("TELEGRAM_BOT_TOKEN tek satÄ±r olmalÄ±.")

          def http_get_json(url, timeout=20, headers=None):
              hdrs = {"User-Agent":"Mozilla/5.0"}
              if headers: hdrs.update(headers)
              req = urllib.request.Request(url, headers=hdrs)
              with urllib.request.urlopen(req, timeout=timeout) as r:
                  return json.loads(r.read().decode())

          def http_post_json(url, payload, timeout=20):
              data = json.dumps(payload).encode("utf-8")
              req = urllib.request.Request(url, data=data, headers={"Content-Type":"application/json"})
              with urllib.request.urlopen(req, timeout=timeout) as r:
                  return json.loads(r.read().decode())

          def send_tg(text):
              url = f"https://api.telegram.org/bot{BOT}/sendMessage"
              parts = [text[i:i+3900] for i in range(0, len(text), 3900)] or [text]
              for p in parts:
                  try:
                      http_post_json(url, {"chat_id": CHAT, "text": p})
                  except urllib.error.HTTPError as e:
                      print("Telegram HTTPError:", e.code, e.read().decode())
                      raise
                  except Exception as e:
                      print("Telegram error:", e); raise

          # --- Veri kaynaklarÄ± ---
          BINANCE_BASES = [
              "https://api.binance.com",
              "https://api1.binance.com",
              "https://api2.binance.com",
              "https://api3.binance.com",
          ]
          YAHOO_SYMBOL = {
              "BTCUSDT":"BTC-USD","ETHUSDT":"ETH-USD","BNBUSDT":"BNB-USD",
              "XRPUSDT":"XRP-USD","SOLUSDT":"SOL-USD"
          }

          def fetch_high_low_binance(sym, limit=200):
              last_err = None
              for base in BINANCE_BASES:
                  url = f"{base}/api/v3/klines?symbol={sym}&interval=1d&limit={limit}"
                  try:
                      kl = http_get_json(url)
                      highs = [float(k[2]) for k in kl]
                      lows  = [float(k[3]) for k in kl]
                      if len(highs) >= 40:   # RSI+SMA iÃ§in yeterli
                          return highs, lows, "binance"
                  except urllib.error.HTTPError as e:
                      last_err = e
                      continue
                  except Exception as e:
                      last_err = e
                      continue
              if last_err: raise last_err
              raise RuntimeError("Binance eriÅŸilemedi")

          def fetch_high_low_yahoo(sym, limit=200):
              ysym = YAHOO_SYMBOL.get(sym)
              if not ysym: 
                  raise RuntimeError(f"Yahoo eÅŸlemesi yok: {sym}")
              # 1y al, en sondan limit kadarÄ±nÄ± kullan
              url = f"https://query1.finance.yahoo.com/v8/finance/chart/{ysym}?interval=1d&range=1y"
              data = http_get_json(url)
              res = data.get("chart",{}).get("result",[])
              if not res: raise RuntimeError(f"Yahoo boÅŸ: {ysym}")
              quote = res[0]["indicators"]["quote"][0]
              highs = [float(x) for x in quote["high"] if x is not None]
              lows  = [float(x) for x in quote["low"]  if x is not None]
              # boylarÄ± eÅŸitle
              n = min(len(highs), len(lows))
              highs, lows = highs[-n:], lows[-n:]
              if len(highs) >= 40:
                  return highs[-limit:], lows[-limit:], "yahoo"
              raise RuntimeError(f"Yahoo veri yetersiz: {ysym}")

          def get_highs_lows(sym):
              try:
                  return fetch_high_low_binance(sym)
              except Exception as e:
                  print(f"[{sym}] Binance olmazsa Yahoo'ya dÃ¼ÅŸÃ¼yorum: {e}")
                  return fetch_high_low_yahoo(sym)

          # --- GÃ¶stergeler ---
          def rsi_wilder(series, period):
              x = list(map(float, series))
              n = len(x); r = [math.nan]*n
              if n <= period: return r
              delta = [x[i]-x[i-1] for i in range(1,n)]
              gains = [d if d>0 else 0.0 for d in delta]
              losses= [-d if d<0 else 0.0 for d in delta]
              avg_g = [math.nan]*n; avg_l = [math.nan]*n
              avg_g[period] = sum(gains[:period])/period
              avg_l[period] = sum(losses[:period])/period
              for i in range(period+1, n):
                  avg_g[i] = (avg_g[i-1]*(period-1) + gains[i-1]) / period
                  avg_l[i] = (avg_l[i-1]*(period-1) + losses[i-1]) / period
              for i in range(period, n):
                  rs = avg_g[i] / (avg_l[i] + 1e-12)
                  r[i] = 100.0 - 100.0/(1.0+rs)
              return r

          def sma(arr, period):
              n = len(arr); out = [math.nan]*n
              for i in range(period-1, n):
                  window = arr[i-period+1:i+1]
                  if any(math.isnan(v) for v in window): continue
                  out[i] = sum(window)/period
              return out

          def now_tr():
              tr = timezone(timedelta(hours=3))
              return datetime.now(tr).strftime("%Y-%m-%d %H:%M:%S %Z")

          def scan():
              symbols = ["BTCUSDT","ETHUSDT","BNBUSDT","XRPUSDT","SOLUSDT"]
              header = f"â±ï¸ {now_tr()}\nðŸ“¡ 1D wick-touch taramasÄ± (2 saatte 1)\nâ³ RSI=14, SMA=14 | EÅŸikler: 0.7 / 1.3\n"
              results = []
              used_source = None

              for sym in symbols:
                  try:
                      highs, lows, source = get_highs_lows(sym)
                      used_source = used_source or source  # ilk bulduÄŸunu yazacaÄŸÄ±z
                      rsi_low  = rsi_wilder(lows, 14)
                      rsi_high = rsi_wilder(highs,14)
                      sma_low  = sma(rsi_low, 14)
                      sma_high = sma(rsi_high,14)

                      rl_c, rl_p = rsi_low[-1],  rsi_low[-2]
                      sl_c, sl_p = sma_low[-1],  sma_low[-2]
                      rh_c, rh_p = rsi_high[-1], rsi_high[-2]
                      sh_c, sh_p = sma_high[-1], sma_high[-2]
                      low_c, high_c = lows[-1], highs[-1]

                      buy  = (not math.isnan(rl_c) and not math.isnan(sl_c) and
                              not math.isnan(rl_p) and not math.isnan(sl_p) and
                              rl_c <= sl_c*0.7 and rl_p > sl_p*0.7)

                      sell = (not math.isnan(rh_c) and not math.isnan(sh_c) and
                              not math.isnan(rh_p) and not math.isnan(sh_p) and
                              rh_c >= sh_c*1.3 and rh_p <  sh_p*1.3)

                      if buy:
                          tp = low_c*1.3
                          results.append(f"ðŸŸ¢ BUY {sym} @ {low_c:.8g} | TPâ‰ˆ{tp:.8g} | RSI(low)={rl_c:.2f} SMA(low)={sl_c:.2f}")
                      if sell:
                          tp = high_c/1.3
                          results.append(f"ðŸ”´ SELL {sym} @ {high_c:.8g} | TPâ‰ˆ{tp:.8g} | RSI(high)={rh_c:.2f} SMA(high)={sh_c:.2f}")

                  except Exception as e:
                      results.append(f"ERR {sym}: {e}")

              src_line = f"\nâ„¹ï¸ Veri kaynaÄŸÄ±: {used_source or 'binanceâ†’yahoo karÄ±ÅŸÄ±k'}"
              body = header + ("\n".join(results) if results else "â€¢ Ä°ÅŸlem yok") + src_line
              send_tg(body)

          if __name__ == "__main__":
              scan()
          PY
